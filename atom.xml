<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhaoyupeng_blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-06T13:20:16.139Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>zhaoyupeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Regular Expression</title>
    <link href="http://example.com/2022/05/06/Regular-Expression/"/>
    <id>http://example.com/2022/05/06/Regular-Expression/</id>
    <published>2022-05-06T12:55:53.000Z</published>
    <updated>2022-05-06T13:20:16.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><strong>掌握了XPath、CSS选择器，为什么还要学习正则？</strong></p><p>正则表达式，用标准正则解析，一般会把HTML当做普通文本，用指定格式匹配当相关文本，适合小片段文本，或者某一串字符(比如电话号码、邮箱账户)，或者HTML包含javascript的代码，无法用CSS选择器或者XPath</p><p><a href="http://tool.oschina.net/regex/">在线正则表达式测试网站</a></p><p><a href="https://docs.python.org/2/library/re.html#regular-expression-objects">官方文档</a></p><p><strong>了解正则表达式</strong></p><p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个”规则字符串”，这个”规则字符串”用来表达对字符串的一种过滤逻辑。</p><h3 id="正则表达式常见概念"><a href="#正则表达式常见概念" class="headerlink" title="正则表达式常见概念"></a>正则表达式常见概念</h3><ul><li><p>边界匹配</p><p>  ^ — 与字符串开始的地方匹配，不匹配任何字符；</p><p>  $ — 与字符串结束的地方匹配，不匹配任何字符；</p></li></ul><p> 复制代码</p><ol><li><code>str = &quot;cat abdcatdetf ios&quot;</code></li><li><code>^cat : 验证该行以c开头紧接着是a，然后是t</code></li><li><code>ios$ : 验证该行以t结尾倒数第二个字符为a倒数第三个字符为c</code></li><li><code>^cat$: 以c开头接着是a-&gt;t然后是行结束：只有cat三个字母的数据行</code></li><li><code>^$ : 开头之后马上结束：空白行，不包括任何字符</code></li><li><code>^ : 行的开头，可以匹配任何行，因为每个行都有行开头</code></li></ol><p>\b — 匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符；</p><p> 复制代码</p><ol><li><code>&quot;er\b&quot;可以匹配&quot;never&quot;中的&quot;er&quot;，但不能匹配&quot;verb&quot;中的&quot;er&quot;。</code></li></ol><p>\B — \b取非，即匹配一个非单词边界；</p><p> 复制代码</p><ol><li><code>&quot;er\B&quot;能匹配&quot;verb&quot;中的&quot;er&quot;，但不能匹配&quot;never&quot;中的&quot;er&quot;。</code></li></ol><ul><li><p>数量词的贪婪模式与非贪婪模式</p><p>  正则表达式通常用于在文本中查找匹配的字符串。Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：</p></li></ul><p> 复制代码</p><ol><li><code>正则表达式&quot;ab*&quot;如果用于查找&quot;abbbc&quot;，将找到&quot;abbb&quot;。而如果使用非贪婪的数量词&quot;ab*?&quot;，将找到&quot;a&quot;。</code></li></ol><ul><li>反斜杠问题</li></ul><p>与大多数编程语言相同，正则表达式里使用”\“作为转义字符，这就可能造成反斜杠困扰。</p><p>假如你需要匹配文本中的字符”\“，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\“：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。</p><p>Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r”\“表示。</p><p>同样，匹配一个数字的”\d”可以写成r”\d”。有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。</p><p> 复制代码</p><ol><li><code>import re</code></li><li><code>a=re.search(r&quot;\\&quot;,&quot;ab123bb\c&quot;)</code></li><li><code>print a.group()</code></li><li><code>\</code></li><li><code>a=re.search(r&quot;\d&quot;,&quot;ab123bb\c&quot;)</code></li><li><code>print a.group()</code></li><li><code>1</code></li></ol><h3 id="Python-Re模块"><a href="#Python-Re模块" class="headerlink" title="Python Re模块"></a>Python Re模块</h3><p>Python 自带了re模块，它提供了对正则表达式的支持。</p><h3 id="match函数"><a href="#match函数" class="headerlink" title="match函数"></a>match函数</h3><p>re.match 尝试从字符串的<strong>起始位置</strong>匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</p><p>下面是此函数的语法：</p><p> 复制代码</p><ol><li><code>re.match(pattern, string, flags=0)</code></li></ol><p>这里的参数的说明：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pattern</td><td>这是正则表达式来进行匹配。</td></tr><tr><td>string</td><td>这是字符串，这将被搜索匹配的模式，在字符串的开头。</td></tr><tr><td>flags</td><td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</td></tr></tbody></table><p>匹配成功re.match方法返回一个匹配的对象，否则返回None。</p><p>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。</p><table><thead><tr><th>匹配对象的方法</th><th>描述</th></tr></thead><tbody><tr><td>group(num&#x3D;0)</td><td>此方法返回整个匹配（或指定分组num）</td></tr><tr><td>groups()</td><td>此方法返回所有元组匹配的子组（空，如果没有）</td></tr></tbody></table><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p> 复制代码</p><ol><li><p><code>#!/usr/bin/python</code></p></li><li><p><code>import re</code></p></li><li><p><code>line = &quot;Cats are smarter than dogs&quot;</code></p></li><li><p><code>matchObj = re.match( r&#39;(.*) are (.*?) .*&#39;, line, re.M|re.I)</code></p></li><li><p><code>if matchObj:</code></p></li><li><p><code>print &quot;matchObj.group() : &quot;, matchObj.group()</code></p></li><li><p><code>print &quot;matchObj.group(1) : &quot;, matchObj.group(1)</code></p></li><li><p><code>print &quot;matchObj.group(2) : &quot;, matchObj.group(2)</code></p></li><li><p><code>else:</code></p></li><li><p><code>print &quot;No match!!&quot;</code></p></li></ol><p>当执行上面的代码，它产生以下结果：</p><p> 复制代码</p><ol><li><code>matchObj.group() : Cats are smarter than dogs</code></li><li><code>matchObj.group(1) : Cats</code></li><li><code>matchObj.group(2) : smarter</code></li></ol><h4 id="正则表达式修饰符-选项标志"><a href="#正则表达式修饰符-选项标志" class="headerlink" title="正则表达式修饰符 - 选项标志"></a>正则表达式修饰符 - 选项标志</h4><p>正则表达式字面可以包含一个可选的修饰符来控制匹配的各个方面。修饰符被指定为一个可选的标志。可以使用异或提供多个修饰符（|），如先前所示，并且可以由这些中的一个来表示：</p><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>re.I(re.IGNORECASE)</td><td>使匹配对大小写不敏感</td></tr><tr><td>re.M(MULTILINE)</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.S(DOTALL)</td><td>使 . 匹配包括换行在内的所有字符</td></tr><tr><td>re.X(VERBOSE)</td><td>正则表达式可以是多行，忽略空白字符，并可以加入注释</td></tr></tbody></table><h3 id="findall-函数"><a href="#findall-函数" class="headerlink" title="findall()函数"></a>findall()函数</h3><p>re.findall(pattern, string, flags&#x3D;0)</p><p>返回字符串中所有模式的非重叠的匹配，作为字符串列表。该字符串扫描左到右，并匹配返回的顺序发现</p><p> 复制代码</p><ol><li><p><code>默认：</code></p></li><li><p><code>pattren = &quot;\w+&quot;</code></p></li><li><p><code>target = &quot;hello world\nWORLD HELLO&quot;</code></p></li><li><p><code>re.findall(pattren,target)</code></p></li><li><p><code>[&#39;hello&#39;, &#39;world&#39;, &#39;WORLD&#39;, &#39;HELLO&#39;]</code></p></li><li><p><code>re.I:</code> </p></li><li><p><code>re.findall(&quot;world&quot;, target,re.I)</code></p></li><li><p><code>[&#39;world&#39;, &#39;WORLD&#39;]</code></p></li><li><p><code>re.S:</code> </p></li><li><p><code>re.findall(&quot;world.WORLD&quot;, target,re.S)</code></p></li><li><p><code>[&quot;world\nworld&quot;]</code></p></li><li><p><code>re.findall(&quot;hello.*WORLD&quot;, target,re.S)</code></p></li><li><p><code>[&#39;hello world\nWORLD&#39;]</code></p></li><li><p><code>re.M:</code></p></li><li><p><code>re.findall(&quot;^WORLD&quot;,target,re.M)</code></p></li><li><p><code>[&quot;WORLD&quot;]</code></p></li><li><p><code>re.X:</code></p></li><li><p><code>reStr = &#39;&#39;&#39;\d&#123;3&#125;  #区号</code></p></li><li><p><code>-\d&#123;8&#125;&#39;&#39;&#39; #号码</code></p></li><li><p><code>re.findall(reStr,&quot;010-12345678&quot;,re.X)</code> </p></li><li><p><code>[&quot;010-12345678&quot;]</code></p></li></ol><h3 id="search函数"><a href="#search函数" class="headerlink" title="search函数"></a>search函数</h3><p>re.search 扫描整个字符串并返回第一个成功的匹配。</p><p>下面是此函数语法：</p><p> 复制代码</p><ol><li><code>re.search(pattern, string, flags=0)</code></li></ol><p>这里的参数说明：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pattern</td><td>这是正则表达式来进行匹配。</td></tr><tr><td>string</td><td>这是字符串，这将被搜索到的字符串中的任何位置匹配的模式。</td></tr><tr><td>flags</td><td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</td></tr></tbody></table><p>匹配成功re.search方法返回一个匹配的对象，否则返回None。</p><p>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。</p><table><thead><tr><th>匹配对象的方法</th><th>描述</th></tr></thead><tbody><tr><td>group(num&#x3D;0)</td><td>此方法返回整个匹配（或指定分组num）</td></tr><tr><td>groups()</td><td>此方法返回所有元组匹配的子组（空，如果没有）</td></tr></tbody></table><h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><p> 复制代码</p><ol><li><p><code>#!/usr/bin/python</code></p></li><li><p><code>import re</code></p></li><li><p><code>line = &quot;Cats are smarter than dogs&quot;;</code></p></li><li><p><code>searchObj = re.search( r&#39;(.*) are (.*?) .*&#39;, line, re.M|re.I)</code></p></li><li><p><code>if searchObj:</code></p></li><li><p><code>print &quot;searchObj.group() : &quot;, searchObj.group()</code></p></li><li><p><code>print &quot;searchObj.group(1) : &quot;, searchObj.group(1)</code></p></li><li><p><code>print &quot;searchObj.group(2) : &quot;, searchObj.group(2)</code></p></li><li><p><code>else:</code></p></li><li><p><code>print &quot;Nothing found!!&quot;</code></p></li></ol><p>当执行上面的代码，它产生以下结果：</p><p> 复制代码</p><ol><li><code>matchObj.group() : Cats are smarter than dogs</code></li><li><code>matchObj.group(1) : Cats</code></li><li><code>matchObj.group(2) : smarter</code></li></ol><h4 id="re-match与re-search的区别"><a href="#re-match与re-search的区别" class="headerlink" title="re.match与re.search的区别"></a>re.match与re.search的区别</h4><p>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p><h4 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h4><p> 复制代码</p><ol><li><p><code>#!/usr/bin/python</code></p></li><li><p><code>import re</code></p></li><li><p><code>line = &quot;Cats are smarter than dogs&quot;;</code></p></li><li><p><code>matchObj = re.match( r&#39;dogs&#39;, line, re.M|re.I)</code></p></li><li><p><code>if matchObj:</code></p></li><li><p><code>print &quot;match --&gt; matchObj.group() : &quot;, matchObj.group()</code></p></li><li><p><code>else:</code></p></li><li><p><code>print &quot;No match!!&quot;</code></p></li><li><p><code>searchObj = re.search( r&#39;dogs&#39;, line, re.M|re.I)</code></p></li><li><p><code>if searchObj:</code></p></li><li><p><code>print &quot;search --&gt; searchObj.group() : &quot;, searchObj.group()</code></p></li><li><p><code>else:</code></p></li><li><p><code>print &quot;Nothing found!!&quot;</code></p></li></ol><p>当执行上面的代码，产生以下结果：</p><p> 复制代码</p><ol><li><code>No match!!</code></li><li><code>search --&gt; matchObj.group() : dogs</code></li></ol><h3 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h3><p>Python 的re模块提供了re.sub用于替换字符串中的匹配项。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p> 复制代码</p><ol><li><code>re.sub(pattern, repl, string, max=0)</code></li></ol><p>返回的字符串是在字符串中用 RE 最左边不重复的匹配来替换。如果模式没有发现，字符将被没有改变地返回。可选参数 count 是模式匹配后替换的最大次数；count 必须是非负整数。缺省值是 0 表示替换所有的匹配。实例：</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>下面是一个爬虫做翻页面例子：</p><p> 复制代码</p><ol><li><p><code>#!/usr/bin/python</code></p></li><li><p><code>import re</code></p></li><li><p><code>url = &quot;http://hr.tencent.com/position.php?&amp;start=10&quot;</code></p></li><li><p><code>page = re.search(&#39;start=(\d+)&#39;,url).group(1)</code></p></li><li><p><code>nexturl = re.sub(r&#39;start=(\d+)&#39;, &#39;start=&#39;+str(int(page)+10), url)</code></p></li><li><p><code>print &quot;Next Url : &quot;, nexturl</code></p></li></ol><p>当执行上面的代码，产生以下结果：</p><p> 复制代码</p><ol><li><code>Next Url : http://hr.tencent.com/position.php?&amp;start=20</code></li></ol><h3 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h3><p>下表列出了Python中可用正则表达式语法：</p><p><img src="https://static.sitestack.cn/projects/piaosanlang-spiders/4fdd105dc5ac24d05a59d8f215937e45.png" alt="非结构化数据之正则表达式 - 图1"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;掌握了XPath、CSS选择器，为什么还要学习正则？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正则表达式，用</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/04/29/hello-world/"/>
    <id>http://example.com/2022/04/29/hello-world/</id>
    <published>2022-04-29T14:27:05.667Z</published>
    <updated>2022-05-04T11:20:17.501Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
